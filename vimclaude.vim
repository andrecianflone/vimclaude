" Vim Plugin: VimClaude
" Description: Automatically reloads buffers modified by Claude without prompting
" Author: Generated by Claude
" Version: 1.0

if exists('g:vimclaude_loaded')
    finish
endif
let g:vimclaude_loaded = 1

" Configuration variables
if !exists('g:vimclaude_enabled')
    let g:vimclaude_enabled = 1
endif

if !exists('g:vimclaude_check_interval')
    let g:vimclaude_check_interval = 500  " milliseconds
endif

if !exists('g:vimclaude_notify')
    let g:vimclaude_notify = 1  " Show notification when file is reloaded
endif

if !exists('g:vimclaude_smart_detection')
    let g:vimclaude_smart_detection = 1  " Enable smart source detection
endif

if !exists('g:vimclaude_show_icons')
    let g:vimclaude_show_icons = 1  " Show emoji icons in notifications
endif

" Store file modification times
let s:file_mtimes = {}

" Function to get Claude process information
function! s:GetClaudeProcessInfo()
    " First, get Claude process PIDs
    let l:claude_pids = split(system('pgrep -i claude 2>/dev/null'), '\n')
    
    if empty(l:claude_pids)
        return []
    endif
    
    let l:claude_processes = []
    for l:pid in l:claude_pids
        if l:pid == ''
            continue
        endif
        
        let l:cwd = ''
        let l:command = ''
        
        " Get working directory using multiple methods
        if has('mac')
            " Method 1: Try pwdx first
            let l:pwdx_result = system('pwdx ' . l:pid . ' 2>/dev/null')
            if l:pwdx_result != '' && l:pwdx_result !~ 'No such process'
                let l:cwd = substitute(l:pwdx_result, '^\d\+:\s*\(.*\)\n*$', '\1', '')
            endif
            
            " Method 2: If pwdx gives us root or empty, try lsof with current working directory
            if l:cwd == '' || l:cwd == '/'
                let l:lsof_result = system('lsof -p ' . l:pid . ' -d cwd -Fn 2>/dev/null | head -1')
                if l:lsof_result =~ '^n/'
                    let l:cwd = substitute(l:lsof_result, '^n\(.*\)\n*$', '\1', '')
                endif
            endif
            
            " Method 3: Try to get from process arguments (sometimes Claude is launched from a specific directory)
            if l:cwd == '' || l:cwd == '/'
                let l:ps_result = system('ps -p ' . l:pid . ' -o args= 2>/dev/null')
                " Look for common directory patterns in the command line
                if l:ps_result =~ '/Users/[^/]*/[^/]*'
                    let l:match = matchstr(l:ps_result, '/Users/[^/]*/[^/]*[^/]*')
                    if l:match != ''
                        let l:cwd = l:match
                    endif
                endif
            endif
            
            " Method 4: Last resort - check if any open files give us a clue about working directory
            if l:cwd == '' || l:cwd == '/'
                let l:lsof_files = system('lsof -p ' . l:pid . ' -Fn 2>/dev/null | grep "^n/Users" | head -5')
                let l:file_lines = split(l:lsof_files, '\n')
                for l:file_line in l:file_lines
                    if l:file_line =~ '^n/Users/[^/]*/[^/]*/'
                        let l:potential_dir = substitute(l:file_line, '^n\(/Users/[^/]*/[^/]*\)/.*$', '\1', '')
                        if l:potential_dir != l:file_line  " Make sure substitution worked
                            let l:cwd = l:potential_dir
                            break
                        endif
                    endif
                endfor
            endif
        else
            " Linux: use /proc filesystem
            let l:cwd = resolve('/proc/' . l:pid . '/cwd')
        endif
        
        " Get command line
        let l:command = system('ps -p ' . l:pid . ' -o command= 2>/dev/null')
        let l:command = substitute(l:command, '\n', '', 'g')
        
        " Clean up cwd - remove any trailing whitespace/newlines
        let l:cwd = substitute(l:cwd, '\s*$', '', '')
        
        " Only add if we got valid info and cwd looks like a real path
        if l:cwd != '' && l:command != '' && l:cwd =~ '^/'
            call add(l:claude_processes, {
                \ 'pid': l:pid,
                \ 'cwd': l:cwd,
                \ 'command': l:command
            \ })
        endif
    endfor
    
    return l:claude_processes
endfunction

" Function to check if file modification was likely from Claude
function! s:IsClaudeModification(filename)
    if !g:vimclaude_smart_detection
        return 0
    endif
    
    let l:claude_processes = s:GetClaudeProcessInfo()
    
    if empty(l:claude_processes)
        return 0
    endif
    
    let l:file_dir = fnamemodify(a:filename, ':p:h')
    
    for l:process in l:claude_processes
        let l:claude_cwd = l:process.cwd
        
        " Method 1: Check if file is in Claude's working directory or subdirectory
        if l:file_dir =~ '^' . escape(l:claude_cwd, '/\.')
            return 1
        endif
        
        " Method 2: Try to detect Claude's target directory for more precise matching
        let l:target_dir = s:GetClaudeTargetDirectory(l:process.pid)
        if l:target_dir != ''
            " Check if file is in the detected target directory
            if l:file_dir =~ '^' . escape(l:target_dir, '/\.')
                return 1
            endif
        endif
        
        " Method 3: Check if Claude's CWD is a parent of the file's directory
        " This handles cases where Claude runs from /Users/name/projects
        " but works on files in /Users/name/projects/stockinfo
        if l:file_dir =~ '^' . escape(l:claude_cwd, '/\.') . '/'
            return 1
        endif
        
        " Method 4: Check if they share a common project root
        " Look for common patterns like both being under the same project directory
        let l:claude_parts = split(l:claude_cwd, '/')
        let l:file_parts = split(l:file_dir, '/')
        
        " If Claude is running from a parent directory, check if file is in a reasonable subdirectory
        if len(l:claude_parts) >= 3 && len(l:file_parts) > len(l:claude_parts)
            " Check if file path starts with Claude's path
            let l:common_parts = l:claude_parts
            let l:file_prefix = join(l:file_parts[0:len(l:common_parts)-1], '/')
            let l:claude_prefix = join(l:common_parts, '/')
            
            if l:file_prefix == l:claude_prefix
                " File is in a subdirectory of Claude's working directory
                return 1
            endif
        endif
    endfor
    
    return 0
endfunction

" Function to check for git operations
function! s:IsGitOperation(filename)
    if !g:vimclaude_smart_detection
        return 0
    endif
    
    " Check if git processes are running
    let l:git_result = system('pgrep git 2>/dev/null')
    if l:git_result != ''
        " Check if file is in a git repository
        let l:file_dir = fnamemodify(a:filename, ':p:h')
        let l:git_dir = system('cd ' . shellescape(l:file_dir) . ' && git rev-parse --git-dir 2>/dev/null')
        return l:git_dir != ''
    endif
    
    return 0
endfunction

" Function to check for build tools
function! s:IsBuildTool(filename)
    if !g:vimclaude_smart_detection
        return 0
    endif
    
    " Only consider it a build tool if:
    " 1. A build tool is running AND
    " 2. The file looks like a build output (not source code)
    
    let l:build_tools = ['webpack', 'gulp', 'grunt', 'make', 'cargo', 'go']
    let l:build_running = 0
    
    for l:tool in l:build_tools
        let l:result = system('pgrep ' . l:tool . ' 2>/dev/null')
        if l:result != ''
            let l:build_running = 1
            break
        endif
    endfor
    
    if !l:build_running
        return 0
    endif
    
    " Check if file looks like build output
    let l:filename = fnamemodify(a:filename, ':t')
    let l:filepath = fnamemodify(a:filename, ':p')
    
    " Common build output patterns
    if l:filepath =~ '\v/(dist|build|target|out|public)/' ||
     \ l:filename =~ '\v\.(min|bundle|compiled)\.(js|css)$' ||
     \ l:filename =~ '\v\.(map|d\.ts)$'
        return 1
    endif
    
    return 0
endfunction

" Function to determine modification source
function! s:GetModificationSource(filename)
    " Priority order: Claude takes precedence over other tools
    " because it's the most specific detection we're looking for
    
    " Check if Claude is running and working in related directory
    if s:IsClaudeModification(a:filename)
        return 'claude'
    endif
    
    " Check for Git operations (more specific than generic build tools)
    if s:IsGitOperation(a:filename)
        return 'git'
    endif
    
    " Check for build tools (least specific, only if others don't match)
    if s:IsBuildTool(a:filename)
        return 'build'
    endif
    
    return 'unknown'
endfunction

" Function to detect Claude's target directory
function! s:GetClaudeTargetDirectory(pid)
    let l:target_dirs = []
    
    " Method 1: Check command line arguments for directory hints
    let l:ps_result = system('ps -p ' . a:pid . ' -o args= 2>/dev/null')
    let l:ps_result = substitute(l:ps_result, '\n', '', 'g')
    
    " Look for directory paths in command line arguments
    let l:dir_matches = []
    for l:match in split(l:ps_result, ' ')
        if l:match =~ '^/.*' && isdirectory(l:match)
            call add(l:dir_matches, l:match)
        endif
    endfor
    
    " Method 2: Check recently accessed files/directories
    let l:lsof_result = system('lsof -p ' . a:pid . ' -Fn 2>/dev/null')
    let l:recent_dirs = {}
    
    for l:line in split(l:lsof_result, '\n')
        if l:line =~ '^n/'
            let l:filepath = substitute(l:line, '^n', '', '')
            if filereadable(l:filepath)
                let l:dir = fnamemodify(l:filepath, ':h')
                let l:recent_dirs[l:dir] = get(l:recent_dirs, l:dir, 0) + 1
            endif
        endif
    endfor
    
    " Method 3: Check for project indicators in subdirectories
    let l:cwd = system('pwdx ' . a:pid . ' 2>/dev/null')
    let l:cwd = substitute(l:cwd, '^\d\+:\s*\(.*\)\n*$', '\1', '')
    
    if l:cwd != '' && isdirectory(l:cwd)
        " Look for common project indicators in subdirectories
        let l:project_indicators = [
            \ 'package.json', 'Cargo.toml', 'pyproject.toml', 'setup.py',
            \ '.git', '.gitignore', 'README.md', 'CLAUDE.md',
            \ 'Makefile', 'CMakeLists.txt', 'pom.xml', 'build.gradle'
        \ ]
        
        for l:subdir in glob(l:cwd . '/*', 0, 1)
            if isdirectory(l:subdir)
                let l:score = 0
                for l:indicator in l:project_indicators
                    if filereadable(l:subdir . '/' . l:indicator) || isdirectory(l:subdir . '/' . l:indicator)
                        let l:score += 1
                    endif
                endfor
                
                " Also check if this directory has recently accessed files
                if has_key(l:recent_dirs, l:subdir)
                    let l:score += l:recent_dirs[l:subdir]
                endif
                
                if l:score > 0
                    call add(l:target_dirs, {'dir': l:subdir, 'score': l:score})
                endif
            endif
        endfor
    endif
    
    " Sort by score (highest first)
    call sort(l:target_dirs, {a, b -> b.score - a.score})
    
    " Return the most likely target directory
    if !empty(l:target_dirs)
        return l:target_dirs[0].dir
    endif
    
    return ''
endfunction

" Debug function to troubleshoot detection
function! VimClaudeDebug(filename)
    let l:filename = fnamemodify(a:filename, ':p')
    echo "=== VimClaude Debug ==="
    echo "File: " . l:filename
    echo "File directory: " . fnamemodify(l:filename, ':h')
    echo ""
    
    " Get Claude PIDs for debugging
    let l:claude_pids = split(system('pgrep -i claude 2>/dev/null'), '\n')
    echo "Claude PIDs found: " . join(l:claude_pids, ', ')
    
    " Test each method for the first PID
    if !empty(l:claude_pids) && l:claude_pids[0] != ''
        let l:test_pid = l:claude_pids[0]
        echo "Testing methods for PID " . l:test_pid . ":"
        
        " Test pwdx
        let l:pwdx_result = system('pwdx ' . l:test_pid . ' 2>/dev/null')
        echo "  pwdx result: " . substitute(l:pwdx_result, '\n', '', 'g')
        
        " Test lsof cwd
        let l:lsof_result = system('lsof -p ' . l:test_pid . ' -d cwd -Fn 2>/dev/null | head -1')
        echo "  lsof cwd result: " . substitute(l:lsof_result, '\n', '', 'g')
        
        " Test command line
        let l:ps_result = system('ps -p ' . l:test_pid . ' -o args= 2>/dev/null')
        echo "  Command line: " . substitute(l:ps_result, '\n', '', 'g')
        
        " Test target directory detection with detailed debugging
        echo "  === Target Directory Detection Debug ==="
        
        " Debug Method 1: Command line arguments
        echo "  Command line args analysis:"
        let l:ps_result = system('ps -p ' . l:test_pid . ' -o args= 2>/dev/null')
        let l:ps_result = substitute(l:ps_result, '\n', '', 'g')
        let l:dir_matches = []
        for l:match in split(l:ps_result, ' ')
            if l:match =~ '^/.*' && isdirectory(l:match)
                call add(l:dir_matches, l:match)
                echo "    Found directory in args: " . l:match
            endif
        endfor
        if empty(l:dir_matches)
            echo "    No directories found in command line args"
        endif
        
        " Debug Method 2: Recently accessed files
        echo "  Recently accessed files analysis:"
        let l:lsof_result = system('lsof -p ' . l:test_pid . ' -Fn 2>/dev/null')
        let l:recent_dirs = {}
        let l:file_count = 0
        
        for l:line in split(l:lsof_result, '\n')
            if l:line =~ '^n/'
                let l:file_count += 1
                let l:filepath = substitute(l:line, '^n', '', '')
                if filereadable(l:filepath)
                    let l:dir = fnamemodify(l:filepath, ':h')
                    let l:recent_dirs[l:dir] = get(l:recent_dirs, l:dir, 0) + 1
                endif
            endif
        endfor
        
        echo "    Total files found: " . l:file_count
        echo "    Directories with files:"
        for [l:dir, l:count] in items(l:recent_dirs)
            if l:count > 0
                echo "      " . l:dir . " (" . l:count . " files)"
            endif
        endfor
        
        " Debug Method 3: Project indicators
        echo "  Project indicators analysis:"
        let l:cwd = system('pwdx ' . l:test_pid . ' 2>/dev/null')
        let l:cwd = substitute(l:cwd, '^\d\+:\s*\(.*\)\n*$', '\1', '')
        echo "    Claude CWD: " . l:cwd
        
        if l:cwd != '' && isdirectory(l:cwd)
            let l:subdirs = glob(l:cwd . '/*', 0, 1)
            echo "    Subdirectories found: " . len(l:subdirs)
            
            let l:project_indicators = [
                \ 'package.json', 'Cargo.toml', 'pyproject.toml', 'setup.py',
                \ '.git', '.gitignore', 'README.md', 'CLAUDE.md',
                \ 'Makefile', 'CMakeLists.txt', 'pom.xml', 'build.gradle'
            \ ]
            
            for l:subdir in l:subdirs[0:4]  " Show first 5 subdirectories
                if isdirectory(l:subdir)
                    let l:score = 0
                    let l:indicators_found = []
                    for l:indicator in l:project_indicators
                        if filereadable(l:subdir . '/' . l:indicator) || isdirectory(l:subdir . '/' . l:indicator)
                            let l:score += 1
                            call add(l:indicators_found, l:indicator)
                        endif
                    endfor
                    
                    if has_key(l:recent_dirs, l:subdir)
                        let l:score += l:recent_dirs[l:subdir]
                    endif
                    
                    echo "      " . l:subdir . " (score: " . l:score . ")"
                    if !empty(l:indicators_found)
                        echo "        Indicators: " . join(l:indicators_found, ', ')
                    endif
                    if has_key(l:recent_dirs, l:subdir)
                        echo "        Recent files: " . l:recent_dirs[l:subdir]
                    endif
                endif
            endfor
        endif
        
        let l:target_dir = s:GetClaudeTargetDirectory(l:test_pid)
        echo "  Final detected target directory: " . (l:target_dir != '' ? l:target_dir : 'None')
    endif
    
    echo ""
    echo "Final processed results:"
    let l:claude_processes = s:GetClaudeProcessInfo()
    if empty(l:claude_processes)
        echo "  None"
    else
        for l:process in l:claude_processes
            echo "  PID: " . l:process.pid . " CWD: " . l:process.cwd
            echo "  Command: " . l:process.command
        endfor
    endif
    
    echo ""
    echo "Path comparison:"
    let l:claude_processes = s:GetClaudeProcessInfo()
    if !empty(l:claude_processes)
        let l:file_dir = fnamemodify(l:filename, ':p:h')
        for l:process in l:claude_processes
            echo "  Claude CWD: " . l:process.cwd
            echo "  File dir:   " . l:file_dir
            echo "  File starts with Claude CWD: " . (l:file_dir =~ '^' . escape(l:process.cwd, '/\.') ? "YES" : "NO")
            echo "  File is subdirectory of Claude CWD: " . (l:file_dir =~ '^' . escape(l:process.cwd, '/\.') . '/' ? "YES" : "NO")
        endfor
    endif
    
    echo ""
    echo "Detection results:"
    echo "  Claude: " . (s:IsClaudeModification(l:filename) ? "YES" : "NO")
    echo "  Git: " . (s:IsGitOperation(l:filename) ? "YES" : "NO")  
    echo "  Build: " . (s:IsBuildTool(l:filename) ? "YES" : "NO")
    echo "  Final source: " . s:GetModificationSource(l:filename)
endfunction

" Function to get smart notification message
function! s:GetSmartNotification(filename, source)
    let l:basename = fnamemodify(a:filename, ':t')
    
    if g:vimclaude_show_icons
        if a:source == 'claude'
            return 'ðŸ¤– Claude modified: ' . l:basename
        elseif a:source == 'git'
            return 'ðŸ”€ Git modified: ' . l:basename  
        elseif a:source == 'build'
            return 'ðŸ”§ Build tool modified: ' . l:basename
        else
            return 'ðŸ“ External modification: ' . l:basename
        endif
    else
        if a:source == 'claude'
            return 'Claude modified: ' . l:basename
        elseif a:source == 'git'
            return 'Git modified: ' . l:basename  
        elseif a:source == 'build'
            return 'Build tool modified: ' . l:basename
        else
            return 'External modification: ' . l:basename
        endif
    endif
endfunction

" Function to check if a file was modified externally
function! s:CheckFileModified(bufnr)
    let l:filename = fnamemodify(bufname(a:bufnr), ':p')
    
    " Skip if file doesn't exist or is not a regular file
    if !filereadable(l:filename) || !filewritable(l:filename)
        return 0
    endif
    
    " Get current modification time
    let l:current_mtime = getftime(l:filename)
    
    " Check if we have a stored mtime for this file
    if has_key(s:file_mtimes, l:filename)
        let l:stored_mtime = s:file_mtimes[l:filename]
        
        " If file was modified externally
        if l:current_mtime > l:stored_mtime
            " Update our stored mtime
            let s:file_mtimes[l:filename] = l:current_mtime
            return 1
        endif
    else
        " First time seeing this file, store its mtime
        let s:file_mtimes[l:filename] = l:current_mtime
    endif
    
    return 0
endfunction

" Function to reload a buffer
function! s:ReloadBuffer(bufnr)
    let l:filename = fnamemodify(bufname(a:bufnr), ':p')
    let l:current_buf = bufnr('%')
    
    " Determine modification source
    let l:source = s:GetModificationSource(l:filename)
    
    " Switch to the buffer that needs reloading
    execute 'buffer ' . a:bufnr
    
    " Save cursor position
    let l:cursor_pos = getpos('.')
    
    " Reload the buffer
    edit!
    
    " Restore cursor position
    call setpos('.', l:cursor_pos)
    
    " Show smart notification if enabled
    if g:vimclaude_notify
        echo s:GetSmartNotification(l:filename, l:source)
    endif
    
    " Switch back to original buffer if it was different
    if l:current_buf != a:bufnr
        execute 'buffer ' . l:current_buf
    endif
endfunction

" Function to check all buffers for external modifications
function! s:CheckAllBuffers(...)
    if !g:vimclaude_enabled
        return
    endif
    
    " Get list of all buffers
    let l:buffers = filter(range(1, bufnr('$')), 'buflisted(v:val)')
    
    for l:bufnr in l:buffers
        " Skip if buffer is modified (has unsaved changes)
        if getbufvar(l:bufnr, '&modified')
            continue
        endif
        
        " Check if file was modified externally
        if s:CheckFileModified(l:bufnr)
            call s:ReloadBuffer(l:bufnr)
        endif
    endfor
endfunction

" Function to start monitoring
function! s:StartMonitoring()
    if exists('s:timer_id')
        return
    endif
    
    let s:timer_id = timer_start(g:vimclaude_check_interval, 
                                \ function('s:CheckAllBuffers'), 
                                \ {'repeat': -1})
    
    if g:vimclaude_notify
        echo "VimClaude: Monitoring started"
    endif
endfunction

" Function to stop monitoring
function! s:StopMonitoring()
    if exists('s:timer_id')
        call timer_stop(s:timer_id)
        unlet s:timer_id
        
        if g:vimclaude_notify
            echo "VimClaude: Monitoring stopped"
        endif
    endif
endfunction

" Function to toggle monitoring
function! s:ToggleMonitoring()
    if exists('s:timer_id')
        call s:StopMonitoring()
    else
        call s:StartMonitoring()
    endif
endfunction

" Public functions
function! VimClaudeStart()
    call s:StartMonitoring()
endfunction

function! VimClaudeStop()
    call s:StopMonitoring()
endfunction

function! VimClaudeToggle()
    call s:ToggleMonitoring()
endfunction

function! VimClaudeStatus()
    if exists('s:timer_id')
        echo "VimClaude: Monitoring is ON"
    else
        echo "VimClaude: Monitoring is OFF"
    endif
endfunction

" Commands
command! VimClaudeStart call VimClaudeStart()
command! VimClaudeStop call VimClaudeStop()
command! VimClaudeToggle call VimClaudeToggle()
command! VimClaudeStatus call VimClaudeStatus()
command! -nargs=? VimClaudeDebug call VimClaudeDebug(<q-args> == '' ? expand('%:p') : <q-args>)

" Auto-start monitoring when Vim starts (if enabled)
if g:vimclaude_enabled
    augroup VimClaude
        autocmd!
        autocmd VimEnter * call s:StartMonitoring()
        autocmd VimLeave * call s:StopMonitoring()
        
        " Update mtime when saving files
        autocmd BufWritePost * let s:file_mtimes[expand('<afile>:p')] = getftime(expand('<afile>:p'))
    augroup END
endif

" Key mappings (optional)
if !exists('g:vimclaude_no_mappings')
    nnoremap <silent> <leader>vcr :VimClaudeToggle<CR>
    nnoremap <silent> <leader>vcs :VimClaudeStatus<CR>
endif