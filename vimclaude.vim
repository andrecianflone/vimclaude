" Vim Plugin: VimClaude
" Description: Automatically reloads buffers modified by Claude without prompting
" Author: Generated by Claude
" Version: 1.0

if exists('g:vimclaude_loaded')
    finish
endif
let g:vimclaude_loaded = 1

" Configuration variables
if !exists('g:vimclaude_enabled')
    let g:vimclaude_enabled = 1
endif

if !exists('g:vimclaude_check_interval')
    let g:vimclaude_check_interval = 500  " milliseconds
endif

if !exists('g:vimclaude_notify')
    let g:vimclaude_notify = 1  " Show notification when file is reloaded
endif

if !exists('g:vimclaude_smart_detection')
    let g:vimclaude_smart_detection = 1  " Enable smart source detection
endif

if !exists('g:vimclaude_show_icons')
    let g:vimclaude_show_icons = 1  " Show emoji icons in notifications
endif

if !exists('g:vimclaude_claude_command')
    let g:vimclaude_claude_command = 'claude'  " Command to launch Claude
endif

" Store file modification times
let s:file_mtimes = {}

" Function to get Claude process information
function! s:GetClaudeProcessInfo()
    " First, get Claude process PIDs
    let l:claude_pids = split(system('pgrep -i claude 2>/dev/null'), '\n')
    
    if empty(l:claude_pids)
        return []
    endif
    
    let l:claude_processes = []
    for l:pid in l:claude_pids
        if l:pid == ''
            continue
        endif
        
        let l:cwd = ''
        let l:command = ''
        
        " Get working directory using multiple methods
        if has('mac')
            " Method 1: Try pwdx first
            let l:pwdx_result = system('pwdx ' . l:pid . ' 2>/dev/null')
            if l:pwdx_result != '' && l:pwdx_result !~ 'No such process'
                let l:cwd = substitute(l:pwdx_result, '^\d\+:\s*\(.*\)\n*$', '\1', '')
            endif
            
            " Method 2: If pwdx gives us root or empty, try lsof with current working directory
            if l:cwd == '' || l:cwd == '/'
                let l:lsof_result = system('lsof -p ' . l:pid . ' -d cwd -Fn 2>/dev/null | head -1')
                if l:lsof_result =~ '^n/'
                    let l:cwd = substitute(l:lsof_result, '^n\(.*\)\n*$', '\1', '')
                endif
            endif
            
            " Method 3: Try to get from process arguments (sometimes Claude is launched from a specific directory)
            if l:cwd == '' || l:cwd == '/'
                let l:ps_result = system('ps -p ' . l:pid . ' -o args= 2>/dev/null')
                " Look for common directory patterns in the command line
                if l:ps_result =~ '/Users/[^/]*/[^/]*'
                    let l:match = matchstr(l:ps_result, '/Users/[^/]*/[^/]*[^/]*')
                    if l:match != ''
                        let l:cwd = l:match
                    endif
                endif
            endif
            
            " Method 4: Last resort - check if any open files give us a clue about working directory
            if l:cwd == '' || l:cwd == '/'
                let l:lsof_files = system('lsof -p ' . l:pid . ' -Fn 2>/dev/null | grep "^n/Users" | head -5')
                let l:file_lines = split(l:lsof_files, '\n')
                for l:file_line in l:file_lines
                    if l:file_line =~ '^n/Users/[^/]*/[^/]*/'
                        let l:potential_dir = substitute(l:file_line, '^n\(/Users/[^/]*/[^/]*\)/.*$', '\1', '')
                        if l:potential_dir != l:file_line  " Make sure substitution worked
                            let l:cwd = l:potential_dir
                            break
                        endif
                    endif
                endfor
            endif
        else
            " Linux: use /proc filesystem
            let l:cwd = resolve('/proc/' . l:pid . '/cwd')
        endif
        
        " Get command line
        let l:command = system('ps -p ' . l:pid . ' -o command= 2>/dev/null')
        let l:command = substitute(l:command, '\n', '', 'g')
        
        " Clean up cwd - remove any trailing whitespace/newlines
        let l:cwd = substitute(l:cwd, '\s*$', '', '')
        
        " Only add if we got valid info and cwd looks like a real path
        if l:cwd != '' && l:command != '' && l:cwd =~ '^/'
            call add(l:claude_processes, {
                \ 'pid': l:pid,
                \ 'cwd': l:cwd,
                \ 'command': l:command
            \ })
        endif
    endfor
    
    return l:claude_processes
endfunction

" Function to check if file modification was likely from Claude
function! s:IsClaudeModification(filename)
    if !g:vimclaude_smart_detection
        return 0
    endif
    
    let l:claude_processes = s:GetClaudeProcessInfo()
    
    if empty(l:claude_processes)
        return 0
    endif
    
    let l:file_dir = fnamemodify(a:filename, ':p:h')
    
    for l:process in l:claude_processes
        let l:claude_cwd = l:process.cwd
        
        " Method 1: Check if file is in Claude's working directory or subdirectory
        if l:file_dir =~ '^' . escape(l:claude_cwd, '/\.')
            return 1
        endif
        
        " Method 2: Try to detect Claude's target directory for more precise matching
        let l:target_dir = s:GetClaudeTargetDirectory(l:process.pid)
        if l:target_dir != ''
            " Check if file is in the detected target directory
            if l:file_dir =~ '^' . escape(l:target_dir, '/\.')
                return 1
            endif
        endif
        
        " Method 3: Check if Claude's CWD is a parent of the file's directory
        " This handles cases where Claude runs from /Users/name/projects
        " but works on files in /Users/name/projects/stockinfo
        if l:file_dir =~ '^' . escape(l:claude_cwd, '/\.') . '/'
            return 1
        endif
        
        " Method 4: Check if they share a common project root
        " Look for common patterns like both being under the same project directory
        let l:claude_parts = split(l:claude_cwd, '/')
        let l:file_parts = split(l:file_dir, '/')
        
        " If Claude is running from a parent directory, check if file is in a reasonable subdirectory
        if len(l:claude_parts) >= 3 && len(l:file_parts) > len(l:claude_parts)
            " Check if file path starts with Claude's path
            let l:common_parts = l:claude_parts
            let l:file_prefix = join(l:file_parts[0:len(l:common_parts)-1], '/')
            let l:claude_prefix = join(l:common_parts, '/')
            
            if l:file_prefix == l:claude_prefix
                " File is in a subdirectory of Claude's working directory
                return 1
            endif
        endif
    endfor
    
    return 0
endfunction

" Function to check for git operations
function! s:IsGitOperation(filename)
    if !g:vimclaude_smart_detection
        return 0
    endif
    
    " Check if git processes are running
    let l:git_result = system('pgrep git 2>/dev/null')
    if l:git_result != ''
        " Check if file is in a git repository
        let l:file_dir = fnamemodify(a:filename, ':p:h')
        let l:git_dir = system('cd ' . shellescape(l:file_dir) . ' && git rev-parse --git-dir 2>/dev/null')
        return l:git_dir != ''
    endif
    
    return 0
endfunction

" Function to check for build tools
function! s:IsBuildTool(filename)
    if !g:vimclaude_smart_detection
        return 0
    endif
    
    " Only consider it a build tool if:
    " 1. A build tool is running AND
    " 2. The file looks like a build output (not source code)
    
    let l:build_tools = ['webpack', 'gulp', 'grunt', 'make', 'cargo', 'go']
    let l:build_running = 0
    
    for l:tool in l:build_tools
        let l:result = system('pgrep ' . l:tool . ' 2>/dev/null')
        if l:result != ''
            let l:build_running = 1
            break
        endif
    endfor
    
    if !l:build_running
        return 0
    endif
    
    " Check if file looks like build output
    let l:filename = fnamemodify(a:filename, ':t')
    let l:filepath = fnamemodify(a:filename, ':p')
    
    " Common build output patterns
    if l:filepath =~ '\v/(dist|build|target|out|public)/' ||
     \ l:filename =~ '\v\.(min|bundle|compiled)\.(js|css)$' ||
     \ l:filename =~ '\v\.(map|d\.ts)$'
        return 1
    endif
    
    return 0
endfunction

" Function to determine modification source
function! s:GetModificationSource(filename)
    " Priority order: Claude takes precedence over other tools
    " because it's the most specific detection we're looking for
    
    " Check if Claude is running and working in related directory
    if s:IsClaudeModification(a:filename)
        return 'claude'
    endif
    
    " Check for Git operations (more specific than generic build tools)
    if s:IsGitOperation(a:filename)
        return 'git'
    endif
    
    " Check for build tools (least specific, only if others don't match)
    if s:IsBuildTool(a:filename)
        return 'build'
    endif
    
    return 'unknown'
endfunction

" Function to detect Claude's target directory
function! s:GetClaudeTargetDirectory(pid)
    let l:target_dirs = []
    
    " Method 1: Check command line arguments for directory hints
    let l:ps_result = system('ps -p ' . a:pid . ' -o args= 2>/dev/null')
    let l:ps_result = substitute(l:ps_result, '\n', '', 'g')
    
    " Look for directory paths in command line arguments
    let l:dir_matches = []
    for l:match in split(l:ps_result, ' ')
        if l:match =~ '^/.*' && isdirectory(l:match)
            call add(l:dir_matches, l:match)
        endif
    endfor
    
    " Method 2: Check recently accessed files/directories
    let l:lsof_result = system('lsof -p ' . a:pid . ' -Fn 2>/dev/null')
    let l:recent_dirs = {}
    
    for l:line in split(l:lsof_result, '\n')
        if l:line =~ '^n/'
            let l:filepath = substitute(l:line, '^n', '', '')
            if filereadable(l:filepath)
                let l:dir = fnamemodify(l:filepath, ':h')
                let l:recent_dirs[l:dir] = get(l:recent_dirs, l:dir, 0) + 1
            endif
        endif
    endfor
    
    " Method 3: Check for project indicators in subdirectories
    let l:cwd = system('pwdx ' . a:pid . ' 2>/dev/null')
    let l:cwd = substitute(l:cwd, '^\d\+:\s*\(.*\)\n*$', '\1', '')
    
    if l:cwd != '' && isdirectory(l:cwd)
        " Look for common project indicators in subdirectories
        let l:project_indicators = [
            \ 'package.json', 'Cargo.toml', 'pyproject.toml', 'setup.py',
            \ '.git', '.gitignore', 'README.md', 'CLAUDE.md',
            \ 'Makefile', 'CMakeLists.txt', 'pom.xml', 'build.gradle'
        \ ]
        
        for l:subdir in glob(l:cwd . '/*', 0, 1)
            if isdirectory(l:subdir)
                let l:score = 0
                for l:indicator in l:project_indicators
                    if filereadable(l:subdir . '/' . l:indicator) || isdirectory(l:subdir . '/' . l:indicator)
                        let l:score += 1
                    endif
                endfor
                
                " Also check if this directory has recently accessed files
                if has_key(l:recent_dirs, l:subdir)
                    let l:score += l:recent_dirs[l:subdir]
                endif
                
                if l:score > 0
                    call add(l:target_dirs, {'dir': l:subdir, 'score': l:score})
                endif
            endif
        endfor
    endif
    
    " Sort by score (highest first)
    call sort(l:target_dirs, {a, b -> b.score - a.score})
    
    " Return the most likely target directory
    if !empty(l:target_dirs)
        return l:target_dirs[0].dir
    endif
    
    return ''
endfunction

" Debug function to troubleshoot detection
function! VimClaudeDebug(filename)
    let l:filename = fnamemodify(a:filename, ':p')
    echo "=== VimClaude Debug ==="
    echo "File: " . l:filename
    echo "File directory: " . fnamemodify(l:filename, ':h')
    echo ""
    
    " Get Claude PIDs for debugging
    let l:claude_pids = split(system('pgrep -i claude 2>/dev/null'), '\n')
    echo "Claude PIDs found: " . join(l:claude_pids, ', ')
    
    " Test each method for the first PID
    if !empty(l:claude_pids) && l:claude_pids[0] != ''
        let l:test_pid = l:claude_pids[0]
        echo "Testing methods for PID " . l:test_pid . ":"
        
        " Test pwdx
        let l:pwdx_result = system('pwdx ' . l:test_pid . ' 2>/dev/null')
        echo "  pwdx result: " . substitute(l:pwdx_result, '\n', '', 'g')
        
        " Test lsof cwd
        let l:lsof_result = system('lsof -p ' . l:test_pid . ' -d cwd -Fn 2>/dev/null | head -1')
        echo "  lsof cwd result: " . substitute(l:lsof_result, '\n', '', 'g')
        
        " Test command line
        let l:ps_result = system('ps -p ' . l:test_pid . ' -o args= 2>/dev/null')
        echo "  Command line: " . substitute(l:ps_result, '\n', '', 'g')
        
        " Test target directory detection with detailed debugging
        echo "  === Target Directory Detection Debug ==="
        
        " Debug Method 1: Command line arguments
        echo "  Command line args analysis:"
        let l:ps_result = system('ps -p ' . l:test_pid . ' -o args= 2>/dev/null')
        let l:ps_result = substitute(l:ps_result, '\n', '', 'g')
        let l:dir_matches = []
        for l:match in split(l:ps_result, ' ')
            if l:match =~ '^/.*' && isdirectory(l:match)
                call add(l:dir_matches, l:match)
                echo "    Found directory in args: " . l:match
            endif
        endfor
        if empty(l:dir_matches)
            echo "    No directories found in command line args"
        endif
        
        " Debug Method 2: Recently accessed files
        echo "  Recently accessed files analysis:"
        let l:lsof_result = system('lsof -p ' . l:test_pid . ' -Fn 2>/dev/null')
        let l:recent_dirs = {}
        let l:file_count = 0
        
        for l:line in split(l:lsof_result, '\n')
            if l:line =~ '^n/'
                let l:file_count += 1
                let l:filepath = substitute(l:line, '^n', '', '')
                if filereadable(l:filepath)
                    let l:dir = fnamemodify(l:filepath, ':h')
                    let l:recent_dirs[l:dir] = get(l:recent_dirs, l:dir, 0) + 1
                endif
            endif
        endfor
        
        echo "    Total files found: " . l:file_count
        echo "    Directories with files:"
        for [l:dir, l:count] in items(l:recent_dirs)
            if l:count > 0
                echo "      " . l:dir . " (" . l:count . " files)"
            endif
        endfor
        
        " Debug Method 3: Project indicators
        echo "  Project indicators analysis:"
        let l:cwd = system('pwdx ' . l:test_pid . ' 2>/dev/null')
        let l:cwd = substitute(l:cwd, '^\d\+:\s*\(.*\)\n*$', '\1', '')
        echo "    Claude CWD: " . l:cwd
        
        if l:cwd != '' && isdirectory(l:cwd)
            let l:subdirs = glob(l:cwd . '/*', 0, 1)
            echo "    Subdirectories found: " . len(l:subdirs)
            
            let l:project_indicators = [
                \ 'package.json', 'Cargo.toml', 'pyproject.toml', 'setup.py',
                \ '.git', '.gitignore', 'README.md', 'CLAUDE.md',
                \ 'Makefile', 'CMakeLists.txt', 'pom.xml', 'build.gradle'
            \ ]
            
            for l:subdir in l:subdirs[0:4]  " Show first 5 subdirectories
                if isdirectory(l:subdir)
                    let l:score = 0
                    let l:indicators_found = []
                    for l:indicator in l:project_indicators
                        if filereadable(l:subdir . '/' . l:indicator) || isdirectory(l:subdir . '/' . l:indicator)
                            let l:score += 1
                            call add(l:indicators_found, l:indicator)
                        endif
                    endfor
                    
                    if has_key(l:recent_dirs, l:subdir)
                        let l:score += l:recent_dirs[l:subdir]
                    endif
                    
                    echo "      " . l:subdir . " (score: " . l:score . ")"
                    if !empty(l:indicators_found)
                        echo "        Indicators: " . join(l:indicators_found, ', ')
                    endif
                    if has_key(l:recent_dirs, l:subdir)
                        echo "        Recent files: " . l:recent_dirs[l:subdir]
                    endif
                endif
            endfor
        endif
        
        let l:target_dir = s:GetClaudeTargetDirectory(l:test_pid)
        echo "  Final detected target directory: " . (l:target_dir != '' ? l:target_dir : 'None')
    endif
    
    echo ""
    echo "Final processed results:"
    let l:claude_processes = s:GetClaudeProcessInfo()
    if empty(l:claude_processes)
        echo "  None"
    else
        for l:process in l:claude_processes
            echo "  PID: " . l:process.pid . " CWD: " . l:process.cwd
            echo "  Command: " . l:process.command
        endfor
    endif
    
    echo ""
    echo "Path comparison:"
    let l:claude_processes = s:GetClaudeProcessInfo()
    if !empty(l:claude_processes)
        let l:file_dir = fnamemodify(l:filename, ':p:h')
        for l:process in l:claude_processes
            echo "  Claude CWD: " . l:process.cwd
            echo "  File dir:   " . l:file_dir
            echo "  File starts with Claude CWD: " . (l:file_dir =~ '^' . escape(l:process.cwd, '/\.') ? "YES" : "NO")
            echo "  File is subdirectory of Claude CWD: " . (l:file_dir =~ '^' . escape(l:process.cwd, '/\.') . '/' ? "YES" : "NO")
        endfor
    endif
    
    echo ""
    echo "Detection results:"
    echo "  Claude: " . (s:IsClaudeModification(l:filename) ? "YES" : "NO")
    echo "  Git: " . (s:IsGitOperation(l:filename) ? "YES" : "NO")  
    echo "  Build: " . (s:IsBuildTool(l:filename) ? "YES" : "NO")
    echo "  Final source: " . s:GetModificationSource(l:filename)
endfunction

" Function to get smart notification message
function! s:GetSmartNotification(filename, source)
    let l:basename = fnamemodify(a:filename, ':t')
    
    if g:vimclaude_show_icons
        if a:source == 'claude'
            return '🤖 Claude modified: ' . l:basename
        elseif a:source == 'git'
            return '🔀 Git modified: ' . l:basename  
        elseif a:source == 'build'
            return '🔧 Build tool modified: ' . l:basename
        else
            return '📝 External modification: ' . l:basename
        endif
    else
        if a:source == 'claude'
            return 'Claude modified: ' . l:basename
        elseif a:source == 'git'
            return 'Git modified: ' . l:basename  
        elseif a:source == 'build'
            return 'Build tool modified: ' . l:basename
        else
            return 'External modification: ' . l:basename
        endif
    endif
endfunction

" Function to check if a file was modified externally
function! s:CheckFileModified(bufnr)
    let l:filename = fnamemodify(bufname(a:bufnr), ':p')
    
    " Skip if file doesn't exist or is not a regular file
    if !filereadable(l:filename) || !filewritable(l:filename)
        return 0
    endif
    
    " Get current modification time
    let l:current_mtime = getftime(l:filename)
    
    " Check if we have a stored mtime for this file
    if has_key(s:file_mtimes, l:filename)
        let l:stored_mtime = s:file_mtimes[l:filename]
        
        " If file was modified externally
        if l:current_mtime > l:stored_mtime
            " Update our stored mtime
            let s:file_mtimes[l:filename] = l:current_mtime
            return 1
        endif
    else
        " First time seeing this file, store its mtime
        let s:file_mtimes[l:filename] = l:current_mtime
    endif
    
    return 0
endfunction

" Function to reload a buffer
function! s:ReloadBuffer(bufnr)
    let l:filename = fnamemodify(bufname(a:bufnr), ':p')
    let l:current_buf = bufnr('%')
    
    " Determine modification source
    let l:source = s:GetModificationSource(l:filename)
    
    " Switch to the buffer that needs reloading
    execute 'buffer ' . a:bufnr
    
    " Save cursor position
    let l:cursor_pos = getpos('.')
    
    " Reload the buffer
    edit!
    
    " Restore cursor position
    call setpos('.', l:cursor_pos)
    
    " Show smart notification if enabled
    if g:vimclaude_notify
        echo s:GetSmartNotification(l:filename, l:source)
    endif
    
    " Switch back to original buffer if it was different
    if l:current_buf != a:bufnr
        execute 'buffer ' . l:current_buf
    endif
endfunction

" Function to check all buffers for external modifications
function! s:CheckAllBuffers(...)
    if !g:vimclaude_enabled
        return
    endif
    
    " Get list of all buffers
    let l:buffers = filter(range(1, bufnr('$')), 'buflisted(v:val)')
    
    for l:bufnr in l:buffers
        " Skip if buffer is modified (has unsaved changes)
        if getbufvar(l:bufnr, '&modified')
            continue
        endif
        
        " Check if file was modified externally
        if s:CheckFileModified(l:bufnr)
            call s:ReloadBuffer(l:bufnr)
        endif
    endfor
endfunction

" Function to start monitoring
function! s:StartMonitoring()
    if exists('s:timer_id')
        return
    endif
    
    let s:timer_id = timer_start(g:vimclaude_check_interval, 
                                \ function('s:CheckAllBuffers'), 
                                \ {'repeat': -1})
    
    if g:vimclaude_notify
        echo "VimClaude: Monitoring started"
    endif
endfunction

" Function to stop monitoring
function! s:StopMonitoring()
    if exists('s:timer_id')
        call timer_stop(s:timer_id)
        unlet s:timer_id
        
        if g:vimclaude_notify
            echo "VimClaude: Monitoring stopped"
        endif
    endif
endfunction

" Function to toggle monitoring
function! s:ToggleMonitoring()
    if exists('s:timer_id')
        call s:StopMonitoring()
    else
        call s:StartMonitoring()
    endif
endfunction

" Public functions
function! VimClaudeStart()
    call s:StartMonitoring()
endfunction

function! VimClaudeStop()
    call s:StopMonitoring()
endfunction

function! VimClaudeToggle()
    call s:ToggleMonitoring()
endfunction

function! VimClaudeStatus()
    if exists('s:timer_id')
        echo "VimClaude: Monitoring is ON"
    else
        echo "VimClaude: Monitoring is OFF"
    endif
endfunction

function! VimClaudeToggleTerminal()
    " Check if Claude terminal is visible in current window
    if &buftype == 'terminal' && bufname('%') =~ '^Claude'
        " Claude is in current window, hide it
        hide
        if g:vimclaude_notify
            echo "VimClaude: Terminal hidden (still running in background)"
        endif
        return
    endif
    
    " Check if Claude terminal exists (visible or hidden)
    let l:claude_bufnr = s:FindClaudeTerminal()
    
    if l:claude_bufnr != -1
        " Claude terminal exists, check if visible
        let l:winnr = bufwinnr(l:claude_bufnr)
        if l:winnr != -1
            " Claude is visible in another window, switch to it and hide
            execute l:winnr . 'wincmd w'
            hide
            if g:vimclaude_notify
                echo "VimClaude: Terminal hidden (still running in background)"
            endif
        else
            " Claude is hidden, show it in vertical split
            execute 'vertical sbuffer ' . l:claude_bufnr
            if g:vimclaude_notify
                echo "VimClaude: Terminal restored from background"
            endif
        endif
    else
        " No Claude terminal exists
        if g:vimclaude_notify
            echo "VimClaude: No Claude terminal found"
        endif
    endif
endfunction

function! VimClaudeAskAboutSelection() range
    " Get the visual selection line numbers
    let l:start_line = line("'<")
    let l:end_line = line("'>")
    let l:start_col = col("'<")
    let l:end_col = col("'>")
    
    " Store selection info for later use
    let s:selection_start = l:start_line
    let s:selection_end = l:end_line
    let s:selection_file = expand('%:t')  " Just filename, not full path
    
    " Create a match to highlight the selected lines
    if exists('w:vimclaude_selection_match')
        call matchdelete(w:vimclaude_selection_match)
    endif
    
    " Highlight the selected lines
    let l:pattern = '\%>' . (l:start_line - 1) . 'l\%<' . (l:end_line + 1) . 'l'
    highlight VimClaudeSelection ctermbg=darkblue ctermfg=white
    let w:vimclaude_selection_match = matchadd('VimClaudeSelection', l:pattern, 100)
    
    " Show popup with line range
    if exists('*popup_create')
        try
            " Create light grey highlight
            highlight VimClaudePopup ctermbg=254 ctermfg=0
            
            " Create popup content showing the selected line range
            let l:line_text = l:start_line == l:end_line ? 
                \ 'Ask Claude about line ' . l:start_line :
                \ 'Ask Claude about lines ' . l:start_line . ' to ' . l:end_line
            
            let l:popup_id = popup_create([
                \ l:line_text,
                \ '════════════════════════════════',
                \ '',
                \ '1. Ask a question',
                \ '2. Explain this code',
                \ '3. Find bugs',
                \ '4. Suggest improvements',
                \ '5. Add comments',
                \ '6. Write tests',
                \ '7. Refactor',
                \ '',
                \ 'Press number or ESC'
                \ ], {
                \ 'pos': 'center',
                \ 'highlight': 'VimClaudePopup',
                \ 'border': [],
                \ 'padding': [0, 1, 0, 1]
                \ })
            
            " Force redraw
            redraw!
            
            " Wait for input
            while 1
                let l:key = getchar()
                if l:key == 27  " ESC
                    call popup_close(l:popup_id)
                    call s:CleanupSelectionHighlight()
                    " Restore visual selection
                    normal! gv
                    echo "VimClaude: Cancelled"
                    return
                elseif l:key >= 49 && l:key <= 55  " '1' to '7'
                    let l:choice = l:key - 48
                    call popup_close(l:popup_id)
                    call s:CleanupSelectionHighlight()
                    call s:HandleAskClaudeChoice(l:choice)
                    return
                endif
            endwhile
            
        catch
            " If popup fails, use fallback menu
            call s:CleanupSelectionHighlight()
            " Try to restore visual selection
            normal! gv
            call s:ShowAskClaudeMenuFallback()
        endtry
    else
        " Fallback for older Vim versions
        call s:ShowAskClaudeMenuFallback()
    endif
endfunction

" Clean up the selection highlight
function! s:CleanupSelectionHighlight()
    if exists('w:vimclaude_selection_match')
        call matchdelete(w:vimclaude_selection_match)
        unlet w:vimclaude_selection_match
    endif
endfunction

" Find Claude terminal buffer
function! s:FindClaudeTerminal()
    " Look for buffers named "Claude" or "Claude - Selection"
    for l:bufnr in range(1, bufnr('$'))
        if bufexists(l:bufnr)
            let l:bufname = bufname(l:bufnr)
            if l:bufname =~ '^Claude'
                " Check if it's a terminal buffer
                if getbufvar(l:bufnr, '&buftype') == 'terminal'
                    return l:bufnr
                endif
            endif
        endif
    endfor
    return -1
endfunction

" Launch Claude or switch to existing terminal
function! s:LaunchOrSwitchToClaude()
    let l:claude_bufnr = s:FindClaudeTerminal()
    
    if l:claude_bufnr != -1
        " Claude terminal exists, find its window
        let l:winnr = bufwinnr(l:claude_bufnr)
        if l:winnr != -1
            " Window is visible, switch to it
            execute l:winnr . 'wincmd w'
            if g:vimclaude_notify
                echo "VimClaude: Switched to existing Claude terminal"
            endif
        else
            " Buffer exists but not visible (hidden), open it in vertical split
            execute 'vertical sbuffer ' . l:claude_bufnr
            if g:vimclaude_notify
                echo "VimClaude: Restored Claude terminal from background"
            endif
        endif
        " Send the explain command to existing terminal
        call s:SendExplainCommand(l:claude_bufnr)
    else
        " No Claude terminal exists, launch new one
        call s:LaunchClaudeWithFlags('')
        " Wait a moment for terminal to initialize, then send command
        call timer_start(500, {-> s:SendExplainCommand(bufnr('%'))})
    endif
endfunction

" Launch Claude for user question (context only, no auto-send)
function! s:LaunchOrSwitchToClaudeForQuestion()
    let l:claude_bufnr = s:FindClaudeTerminal()
    
    if l:claude_bufnr != -1
        " Claude terminal exists, find its window
        let l:winnr = bufwinnr(l:claude_bufnr)
        if l:winnr != -1
            " Window is visible, switch to it
            execute l:winnr . 'wincmd w'
            if g:vimclaude_notify
                echo "VimClaude: Switched to Claude - type your question"
            endif
        else
            " Buffer exists but not visible (hidden), open it in vertical split
            execute 'vertical sbuffer ' . l:claude_bufnr
            if g:vimclaude_notify
                echo "VimClaude: Restored Claude - type your question"
            endif
        endif
        " Send only the context reference (no question)
        call s:SendContextReference(l:claude_bufnr)
    else
        " No Claude terminal exists, launch new one
        call s:LaunchClaudeWithFlags('')
        " Wait a moment for terminal to initialize, then send context
        call timer_start(500, {-> s:SendContextReference(bufnr('%'))})
    endif
endfunction

" Send explain command to Claude terminal
function! s:SendExplainCommand(bufnr)
    " Construct the message
    let l:line_text = s:selection_start == s:selection_end ? 
        \ 'line ' . s:selection_start :
        \ 'lines ' . s:selection_start . ' to ' . s:selection_end
    let l:message = 'Look at ' . l:line_text . ' in file ' . s:selection_file . '. Please explain this code.'
    
    " Send text to terminal
    if has('nvim')
        call chansend(getbufvar(a:bufnr, '&channel'), l:message)
        " Send Enter key separately after a longer delay
        call timer_start(300, {-> chansend(getbufvar(a:bufnr, '&channel'), "\r")})
    else
        call term_sendkeys(a:bufnr, l:message)
        " Send Enter key separately after a longer delay
        call timer_start(300, {-> term_sendkeys(a:bufnr, "\r")})
    endif
endfunction

" Send context reference only (for user questions)
function! s:SendContextReference(bufnr)
    " Construct the context message
    let l:line_text = s:selection_start == s:selection_end ? 
        \ 'line ' . s:selection_start :
        \ 'lines ' . s:selection_start . ' to ' . s:selection_end
    let l:message = 'Look at ' . l:line_text . ' in file ' . s:selection_file . '. '
    
    " Send text to terminal (no Enter key - user will type their question)
    if has('nvim')
        call chansend(getbufvar(a:bufnr, '&channel'), l:message)
    else
        call term_sendkeys(a:bufnr, l:message)
    endif
endfunction

" Monitor Claude terminal and auto-close when finished
function! s:MonitorClaudeTerminal()
    let l:bufnr = bufnr('%')
    let l:winnr = winnr()
    
    " Set up a timer to check terminal status
    let l:timer_id = timer_start(100, function('s:CheckClaudeTerminalFinished', [l:bufnr, l:winnr]), {'repeat': -1})
    
    " Store timer ID in buffer variable for cleanup
    call setbufvar(l:bufnr, 'vimclaude_monitor_timer', l:timer_id)
endfunction

" Check if Claude terminal has finished and close window
function! s:CheckClaudeTerminalFinished(bufnr, winnr, timer_id)
    " Check if buffer still exists
    if !bufexists(a:bufnr)
        call timer_stop(a:timer_id)
        return
    endif
    
    " Check if terminal job is finished
    let l:job_status = term_getstatus(a:bufnr)
    if l:job_status == 'finished'
        " Stop the timer first
        call timer_stop(a:timer_id)
        
        " Find and close the window containing this buffer
        let l:win_id = bufwinid(a:bufnr)
        if l:win_id != -1
            " Use try-catch to handle any errors
            try
                call win_execute(l:win_id, 'close!')
            catch
                " If close fails, try alternative approach
                let l:winnr = bufwinnr(a:bufnr)
                if l:winnr != -1
                    execute l:winnr . 'wincmd c'
                endif
            endtry
        endif
        
        " Try to delete the buffer if it still exists
        if bufexists(a:bufnr)
            try
                execute 'bdelete!' a:bufnr
            catch
                " Buffer might be modified or have other issues
                " Try wiping it out completely
                try
                    execute 'bwipeout!' a:bufnr
                catch
                    " If all else fails, just ignore
                endtry
            endtry
        endif
    endif
endfunction

" Handle the choice from the Ask Claude menu
function! s:HandleAskClaudeChoice(choice)
    let l:line_text = s:selection_start == s:selection_end ? 
        \ 'line ' . s:selection_start :
        \ 'lines ' . s:selection_start . ' to ' . s:selection_end
    
    if a:choice == 1
        " Ask a question - launch Claude and send context only
        call s:LaunchOrSwitchToClaudeForQuestion()
    elseif a:choice == 2
        " Explain this code - launch or switch to Claude
        call s:LaunchOrSwitchToClaude()
    elseif a:choice == 3
        echo "VimClaude: Finding bugs in " . l:line_text
    elseif a:choice == 4
        echo "VimClaude: Suggesting improvements for " . l:line_text
    elseif a:choice == 5
        echo "VimClaude: Adding comments to " . l:line_text
    elseif a:choice == 6
        echo "VimClaude: Writing tests for " . l:line_text
    elseif a:choice == 7
        echo "VimClaude: Refactoring " . l:line_text
    endif
endfunction

" Fallback menu for older Vim versions
function! s:ShowAskClaudeMenuFallback()
    let l:line_text = s:selection_start == s:selection_end ? 
        \ 'line ' . s:selection_start :
        \ 'lines ' . s:selection_start . ' to ' . s:selection_end
    
    let l:choices = [
        \ "Ask Claude about " . l:line_text . ":",
        \ "1. Ask a question",
        \ "2. Explain this code",
        \ "3. Find bugs",
        \ "4. Suggest improvements",
        \ "5. Add comments",
        \ "6. Write tests",
        \ "7. Refactor"
    \ ]
    
    let l:choice = inputlist(l:choices)
    if l:choice >= 1 && l:choice <= 7
        call s:HandleAskClaudeChoice(l:choice)
    else
        echo "VimClaude: Cancelled"
    endif
endfunction

" Function to launch Claude with specific flags
function! s:LaunchClaudeWithFlags(flags)
    let l:claude_cmd = g:vimclaude_claude_command
    let l:full_cmd = l:claude_cmd . (a:flags != '' ? ' ' . a:flags : '')
    
    try
        execute 'vertical terminal ' . l:full_cmd
        
        " Set terminal buffer name to "Claude"
        if has('nvim')
            " Neovim: rename the buffer
            execute 'file Claude'
        else
            " Vim: set buffer name
            let l:bufnr = bufnr('%')
            execute 'file Claude'
            " Also try to set the terminal title if function exists
            if exists('*term_settitle')
                call term_settitle(l:bufnr, 'Claude')
            endif
        endif
        
        if g:vimclaude_notify
            let l:session_type = a:flags == '--continue' ? 'continuing session' : 
                               \ a:flags == '--resume' ? 'resuming session' : 'new session'
            echo "VimClaude: Launched Claude in terminal (" . l:session_type . ")"
        endif
    catch
        echohl ErrorMsg
        echo "VimClaude: Failed to launch Claude terminal: " . v:exception
        echohl None
    endtry
endfunction

" Function to handle popup menu selection
function! s:HandlePopupSelection(choice)
    if a:choice == 1
        call s:LaunchClaudeWithFlags('--continue')
    elseif a:choice == 2
        call s:LaunchClaudeWithFlags('--resume')
    elseif a:choice == 3
        call s:LaunchClaudeWithFlags('')
    else
        if g:vimclaude_notify
            echo "VimClaude: Launch cancelled"
        endif
    endif
endfunction

" Function to show session selection popup (modern Vim/Neovim)
function! s:ShowSessionPopup()
    let l:menu_items = [
        \ "Continue session (--continue)",
        \ "Select session (--resume)",
        \ "New session"
    \ ]
    
    " Calculate popup dimensions
    let l:max_width = 0
    for l:item in l:menu_items
        let l:item_len = len(l:item)
        if l:item_len > l:max_width
            let l:max_width = l:item_len
        endif
    endfor
    let l:width = l:max_width + 4
    let l:height = len(l:menu_items) + 2
    
    " Center the popup
    let l:row = (&lines - l:height) / 2
    let l:col = (&columns - l:width) / 2
    
    if has('nvim')
        " Neovim implementation
        let l:buf = nvim_create_buf(v:false, v:true)
        
        " Add title and menu items
        let l:lines = ["Start Claude Code:"] + l:menu_items
        call nvim_buf_set_lines(l:buf, 0, -1, v:false, l:lines)
        
        " Create popup window
        let l:opts = {
            \ 'relative': 'editor',
            \ 'width': l:width,
            \ 'height': l:height,
            \ 'row': l:row,
            \ 'col': l:col,
            \ 'style': 'minimal',
            \ 'border': 'rounded'
        \ }
        
        let l:win = nvim_open_win(l:buf, v:true, l:opts)
        
        " Set up key mappings for navigation
        nnoremap <buffer> <CR> :call <SID>SelectFromPopup()<CR>
        nnoremap <buffer> <Esc> :call <SID>ClosePopup()<CR>
        nnoremap <buffer> q :call <SID>ClosePopup()<CR>
        nnoremap <buffer> 1 :call <SID>HandlePopupSelection(1)<CR>:call <SID>ClosePopup()<CR>
        nnoremap <buffer> 2 :call <SID>HandlePopupSelection(2)<CR>:call <SID>ClosePopup()<CR>
        nnoremap <buffer> 3 :call <SID>HandlePopupSelection(3)<CR>:call <SID>ClosePopup()<CR>
        
        " Store popup info for later use
        let s:popup_buf = l:buf
        let s:popup_win = l:win
        
        " Position cursor on first menu item
        call nvim_win_set_cursor(l:win, [2, 0])
        
    else
        " Vim 8.2+ implementation  
        if exists('*popup_create')
            " Test with a simple popup that stays visible
            try
                " Create light grey highlight
                highlight VimClaudePopup ctermbg=254 ctermfg=0
                
                " Use the same simple style that worked in your test
                let l:popup_id = popup_create([
                    \ 'Start Claude Code:',
                    \ '========================',
                    \ '1. Continue last chat',
                    \ '2. Select chat to resume',
                    \ '3. New chat',
                    \ '',
                    \ 'Press number or ESC'
                    \ ], {
                    \ 'pos': 'center',
                    \ 'highlight': 'VimClaudePopup',
                    \ 'border': [],
                    \ 'padding': [0, 1, 0, 1]
                    \ })
                
                " Force redraw
                redraw!
                
                " Wait for input
                let l:choice = 0
                while l:choice == 0
                    let l:key = getchar()
                    if l:key == 27  " ESC
                        call popup_close(l:popup_id)
                        if g:vimclaude_notify
                            echo "VimClaude: Launch cancelled"
                        endif
                        return
                    elseif l:key >= 49 && l:key <= 51  " '1' to '3'
                        let l:choice = l:key - 48
                        call popup_close(l:popup_id)
                        call s:HandlePopupSelection(l:choice)
                        return
                    endif
                endwhile
                
            catch
                " If popup fails, show error and use fallback
                echom "Popup error: " . v:exception
                call s:ShowSessionMenuFallback()
            endtry
            
        else
            " Fallback to inputlist for older Vim versions
            call s:ShowSessionMenuFallback()
        endif
    endif
endfunction

" Popup filter function for Vim 8.2+
function! s:PopupFilter(winid, key)
    if a:key == "\<Down>" || a:key == 'j'
        let s:popup_selected = min([s:popup_selected + 1, 3])
        call popup_setoptions(a:winid, {'cursorline': s:popup_selected + 2})
        return 1
    elseif a:key == "\<Up>" || a:key == 'k'
        let s:popup_selected = max([s:popup_selected - 1, 1])
        call popup_setoptions(a:winid, {'cursorline': s:popup_selected + 2})
        return 1
    elseif a:key == "\<CR>" || a:key == "\<Space>"
        call popup_close(a:winid, s:popup_selected)
        return 1
    elseif a:key == "\<Esc>" || a:key == 'q'
        call popup_close(a:winid, 0)
        return 1
    elseif a:key >= '1' && a:key <= '3'
        let l:choice = str2nr(a:key)
        call popup_close(a:winid, l:choice)
        return 1
    endif
    return 0
endfunction

" Popup callback function for Vim 8.2+
function! s:PopupCallback(winid, result)
    call s:HandlePopupSelection(a:result)
endfunction

" Popup menu callback function
function! s:PopupMenuCallback(winid, result)
    if a:result > 0
        call s:HandlePopupSelection(a:result)
    else
        if g:vimclaude_notify
            echo "VimClaude: Launch cancelled"
        endif
    endif
endfunction

" Helper functions for Neovim popup
function! s:SelectFromPopup()
    let l:line = line('.')
    let l:choice = l:line - 1  " Adjust for title line
    if l:choice >= 1 && l:choice <= 3
        call s:HandlePopupSelection(l:choice)
    endif
    call s:ClosePopup()
endfunction

function! s:ClosePopup()
    if exists('s:popup_win')
        call nvim_win_close(s:popup_win, v:true)
        unlet s:popup_win
    endif
    if exists('s:popup_buf')
        call nvim_buf_delete(s:popup_buf, {'force': v:true})
        unlet s:popup_buf
    endif
endfunction

" Fallback menu for older Vim versions
function! s:ShowSessionMenuFallback()
    let l:choices = [
        \ "Claude Session Options:",
        \ "1. Continue session (--continue)",
        \ "2. Select session (--resume)", 
        \ "3. New session"
    \ ]
    
    let l:choice = inputlist(l:choices)
    call s:HandlePopupSelection(l:choice)
endfunction

" Main function to show session selection menu
function! s:ShowSessionMenu()
    if has('nvim') || exists('*popup_create')
        call s:ShowSessionPopup()
    else
        call s:ShowSessionMenuFallback()
    endif
endfunction

function! VimClaudeLaunch()
    " Check if Claude command is available
    let l:claude_cmd = g:vimclaude_claude_command
    let l:check_result = system('command -v ' . shellescape(l:claude_cmd) . ' >/dev/null 2>&1; echo $?')
    
    if str2nr(l:check_result) != 0
        echohl ErrorMsg
        echo "VimClaude: Claude command '" . l:claude_cmd . "' not found in PATH"
        echohl None
        echo "Configure with: let g:vimclaude_claude_command = '/path/to/claude'"
        return
    endif
    
    " Check if we're in a terminal-capable Vim
    if !has('terminal')
        echohl ErrorMsg
        echo "VimClaude: Terminal feature not available in this Vim version"
        echohl None
        return
    endif
    
    " First check if Claude terminal already exists (hidden or visible)
    let l:claude_bufnr = s:FindClaudeTerminal()
    
    if l:claude_bufnr != -1
        " Claude terminal exists, check if it's hidden or visible
        let l:winnr = bufwinnr(l:claude_bufnr)
        if l:winnr == -1
            " Claude is hidden, restore it and skip the popup
            execute 'vertical sbuffer ' . l:claude_bufnr
            if g:vimclaude_notify
                echo "VimClaude: Terminal restored from background"
            endif
        else
            " Claude is visible, switch to it and skip the popup
            execute l:winnr . 'wincmd w'
            if g:vimclaude_notify
                echo "VimClaude: Switched to existing Claude terminal"
            endif
        endif
        return
    endif
    
    " No Claude terminal exists, show session selection menu
    call s:ShowSessionMenu()
endfunction

" Commands
command! VimClaudeStart call VimClaudeStart()
command! VimClaudeStop call VimClaudeStop()
command! VimClaudeToggle call VimClaudeToggle()
command! VimClaudeStatus call VimClaudeStatus()
command! VimClaudeLaunch call VimClaudeLaunch()
command! VimClaudeToggleTerminal call VimClaudeToggleTerminal()
command! -range VimClaudeAskAboutSelection <line1>,<line2>call VimClaudeAskAboutSelection()
command! -nargs=? VimClaudeDebug call VimClaudeDebug(<q-args> == '' ? expand('%:p') : <q-args>)

" Auto-start monitoring when Vim starts (if enabled)
if g:vimclaude_enabled
    augroup VimClaude
        autocmd!
        autocmd VimEnter * call s:StartMonitoring()
        autocmd VimLeave * call s:StopMonitoring()
        
        " Update mtime when saving files
        autocmd BufWritePost * let s:file_mtimes[expand('<afile>:p')] = getftime(expand('<afile>:p'))
        
        " Auto-close Claude terminal windows when the terminal exits
        if has('nvim')
            autocmd TermClose * if expand('<afile>') =~ 'Claude' | close | endif
        else
            " For Vim, set up terminal finish monitoring
            autocmd TerminalWinOpen * if expand('<afile>') =~ 'Claude' | call s:MonitorClaudeTerminal() | endif
        endif
    augroup END
endif

" Key mappings (optional)
if !exists('g:vimclaude_no_mappings')
    nnoremap <silent> <leader>vcr :VimClaudeToggle<CR>
    nnoremap <silent> <leader>vcs :VimClaudeStatus<CR>
    nnoremap <silent> <leader>vc :VimClaudeLaunch<CR>
    vnoremap <silent> <leader>vc :call VimClaudeAskAboutSelection()<CR>
    nnoremap <silent> <leader>vct :VimClaudeToggleTerminal<CR>
    
    " Terminal mode mapping to hide Claude terminal
    if has('nvim')
        tnoremap <silent> <leader>vct <C-\><C-n>:VimClaudeToggleTerminal<CR>
    else
        tnoremap <silent> <leader>vct <C-w>:VimClaudeToggleTerminal<CR>
    endif
endif
